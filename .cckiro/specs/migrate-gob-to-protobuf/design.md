# Design: Migrate from gob to Protocol Buffers

## 1. Overview

This document describes the detailed design for migrating the message encoding/decoding mechanism from Go's `encoding/gob` to Protocol Buffers (protobuf).

## 2. Design Goals

1. Maintain existing API surface (method signatures and public types)
2. Minimize code changes outside of `pkg/protocol`
3. Enable automated protobuf code generation
4. Support TDD workflow with incremental changes
5. Follow conventional commit strategy

## 3. Architecture Overview

### 3.1 Component Structure

```
pkg/protocol/
├── message.proto          (NEW) - Protocol Buffer schema
├── message.pb.go          (NEW) - Generated protobuf code
├── message.go             (MODIFIED) - Existing Go types and methods
└── message_test.go        (MODIFIED) - Tests updated for protobuf
```

### 3.2 Design Strategy

**Strategy: Dual-Type Approach with Conversion Layer**

We will maintain the existing Go types (`Message`, `MessageType`) and add a conversion layer to/from protobuf-generated types. This approach:

- ✅ Maintains existing API surface (no breaking changes)
- ✅ Isolates protobuf details from the rest of the codebase
- ✅ Allows incremental migration
- ✅ Keeps existing tests working with minimal changes

**Alternative Approaches Considered:**

1. **Replace Go types with protobuf types directly**
   - ❌ Would break existing API
   - ❌ Would require changes throughout codebase
   - ❌ Violates requirement FR3.3 (maintain method signatures)

2. **Embed protobuf types in existing structs**
   - ❌ Leaks protobuf implementation details
   - ❌ Complicates struct initialization
   - ❌ Makes testing more complex

## 4. Protocol Buffer Schema Design

### 4.1 Schema Definition

**File:** `pkg/protocol/message.proto`

```protobuf
syntax = "proto3";

package protocol;

option go_package = "github.com/omochice/toy-socket-chat/pkg/protocol";

// MessageType represents the type of message
enum MessageType {
  // Text message from a user
  MESSAGE_TYPE_TEXT = 0;
  // User joined notification
  MESSAGE_TYPE_JOIN = 1;
  // User left notification
  MESSAGE_TYPE_LEAVE = 2;
}

// Message represents a chat message
message Message {
  // Type of the message
  MessageType type = 1;
  // Username of the sender
  string sender = 2;
  // Content of the message (empty for JOIN/LEAVE)
  string content = 3;
}
```

### 4.2 Design Decisions

#### Decision 4.2.1: Enum Naming Convention

**Decision:** Use `MESSAGE_TYPE_` prefix for enum values in proto

**Rationale:**
- proto3 requires globally unique enum value names within a package
- Prefix prevents naming conflicts
- Generated Go code will handle conversion automatically

**Trade-off:**
- Proto enum names differ from Go constant names
- Acceptable because conversion layer hides this difference

#### Decision 4.2.2: Field Numbers

**Decision:** Use sequential field numbers starting from 1

**Rationale:**
- Fields 1-15 are most efficient (1 byte encoding)
- We only have 3 fields, all fit in efficient range
- Sequential numbering is clearest for small schemas

#### Decision 4.2.3: Proto3 Syntax

**Decision:** Use `syntax = "proto3"`

**Rationale:**
- Requirement FR1.4 explicitly requires proto3
- proto3 is the current standard
- Simpler than proto2 (no required/optional complexity)

### 4.3 Mapping to Go Types

| Proto Type | Go Type (Generated) | Go Type (Existing) |
|------------|---------------------|---------------------|
| `MessageType` enum | `protocol.MessageType` (int32) | `protocol.MessageType` (int) |
| `MESSAGE_TYPE_TEXT` | `protocol.MessageType_MESSAGE_TYPE_TEXT` | `protocol.MessageTypeText` |
| `MESSAGE_TYPE_JOIN` | `protocol.MessageType_MESSAGE_TYPE_JOIN` | `protocol.MessageTypeJoin` |
| `MESSAGE_TYPE_LEAVE` | `protocol.MessageType_MESSAGE_TYPE_LEAVE` | `protocol.MessageTypeLeave` |
| `Message` message | `protocol.Message` | `protocol.Message` |

**Naming Conflict Resolution:**

The generated protobuf code will create types with the same names as our existing types. We will resolve this by:

1. Renaming the protobuf-generated `Message` type using a Go type alias or by prefixing
2. Using the generated types internally for serialization only
3. Keeping the existing public API unchanged

**Approach:** Use internal conversion functions to bridge between user-facing types and protobuf types.

## 5. Go Implementation Design

### 5.1 File Structure

#### 5.1.1 message.proto (NEW)

Contains the Protocol Buffer schema as defined in Section 4.1.

#### 5.1.2 message.pb.go (NEW - Generated)

Generated by `protoc`. Contains:
- Protobuf message types
- Marshal/Unmarshal methods
- Protobuf reflection support

**Important:** This file should NOT be manually edited. It will be regenerated when the proto file changes.

#### 5.1.3 message.go (MODIFIED)

**Current structure:**
```go
type MessageType int
const (
    MessageTypeText MessageType = iota
    MessageTypeJoin
    MessageTypeLeave
)

type Message struct {
    Type    MessageType
    Sender  string
    Content string
}

func (m *Message) Encode() ([]byte, error)
func (m *Message) Decode(data []byte) error
func (mt MessageType) String() string
```

**New structure:**
```go
// Existing public types (UNCHANGED)
type MessageType int
const (
    MessageTypeText MessageType = iota
    MessageTypeJoin
    MessageTypeLeave
)

type Message struct {
    Type    MessageType
    Sender  string
    Content string
}

// Existing public methods (IMPLEMENTATION CHANGED)
func (m *Message) Encode() ([]byte, error)
func (m *Message) Decode(data []byte) error
func (mt MessageType) String() string

// New internal conversion functions (ADDED)
func (m *Message) toProto() *pbMessage
func (m *Message) fromProto(pb *pbMessage)
func messageTypeToProto(mt MessageType) pbMessageType
func messageTypeFromProto(pb pbMessageType) MessageType
```

### 5.2 Conversion Layer Design

#### 5.2.1 Message to Protobuf

```go
// toProto converts the user-facing Message to protobuf Message
func (m *Message) toProto() *pbMessage {
    return &pbMessage{
        Type:    messageTypeToProto(m.Type),
        Sender:  m.Sender,
        Content: m.Content,
    }
}
```

**Note:** We use lowercase method name to keep it package-private.

#### 5.2.2 Protobuf to Message

```go
// fromProto populates the user-facing Message from protobuf Message
func (m *Message) fromProto(pb *pbMessage) {
    m.Type = messageTypeFromProto(pb.Type)
    m.Sender = pb.Sender
    m.Content = pb.Content
}
```

#### 5.2.3 MessageType Conversion

```go
// messageTypeToProto converts MessageType to protobuf enum
func messageTypeToProto(mt MessageType) pbMessageType {
    switch mt {
    case MessageTypeText:
        return pbMessageType_MESSAGE_TYPE_TEXT
    case MessageTypeJoin:
        return pbMessageType_MESSAGE_TYPE_JOIN
    case MessageTypeLeave:
        return pbMessageType_MESSAGE_TYPE_LEAVE
    default:
        return pbMessageType_MESSAGE_TYPE_TEXT
    }
}

// messageTypeFromProto converts protobuf enum to MessageType
func messageTypeFromProto(pb pbMessageType) MessageType {
    switch pb {
    case pbMessageType_MESSAGE_TYPE_TEXT:
        return MessageTypeText
    case pbMessageType_MESSAGE_TYPE_JOIN:
        return MessageTypeJoin
    case pbMessageType_MESSAGE_TYPE_LEAVE:
        return MessageTypeLeave
    default:
        return MessageTypeText
    }
}
```

**Design Decision:** Handle unknown enum values by defaulting to TEXT (safest option for a chat system).

### 5.3 Encode/Decode Implementation

#### 5.3.1 Encode Method

```go
// Encode encodes the message into bytes using protobuf
func (m *Message) Encode() ([]byte, error) {
    pb := m.toProto()
    data, err := proto.Marshal(pb)
    if err != nil {
        return nil, fmt.Errorf("failed to encode message: %w", err)
    }
    return data, nil
}
```

**Changes from current implementation:**
- Replace `gob.NewEncoder()` with `proto.Marshal()`
- Replace `bytes.Buffer` with direct marshaling
- Keep error wrapping format for consistency

#### 5.3.2 Decode Method

```go
// Decode decodes bytes into a message using protobuf
func (m *Message) Decode(data []byte) error {
    pb := &pbMessage{}
    if err := proto.Unmarshal(data, pb); err != nil {
        return fmt.Errorf("failed to decode message: %w", err)
    }
    m.fromProto(pb)
    return nil
}
```

**Changes from current implementation:**
- Replace `gob.NewDecoder()` with `proto.Unmarshal()`
- Remove `bytes.NewBuffer()` as protobuf works directly with byte slices
- Keep error wrapping format for consistency

#### 5.3.3 String Method

**No changes required.** The `MessageType.String()` method remains unchanged as it doesn't depend on the encoding mechanism.

### 5.4 Import Changes

**Current imports:**
```go
import (
    "bytes"
    "encoding/gob"
    "fmt"
)
```

**New imports:**
```go
import (
    "fmt"

    "google.golang.org/protobuf/proto"
)
```

**Removed:**
- `bytes` - No longer needed (protobuf works directly with byte slices)
- `encoding/gob` - Replaced by protobuf

**Added:**
- `google.golang.org/protobuf/proto` - For Marshal/Unmarshal

### 5.5 Naming Strategy for Generated Types

**Challenge:** The generated protobuf code will create a `Message` type that conflicts with our existing `Message` type.

**Solution:** Use build tags or internal package structure.

**Chosen Approach: Import Aliasing**

```go
import (
    pb "github.com/omochice/toy-socket-chat/pkg/protocol/pb"
)
```

**Alternative:** Generate proto code to `pkg/protocol/pb/` subdirectory

**Decision:** Generate to subdirectory `pkg/protocol/pb/`

**Rationale:**
- Avoids naming conflicts completely
- Clear separation between generated and manual code
- Standard practice in Go protobuf projects
- Easy to add to `.gitignore` if needed (though we commit generated code per FR2.2)

**Updated Structure:**
```
pkg/protocol/
├── pb/
│   ├── message.pb.go      (NEW) - Generated protobuf code
│   └── message.proto      (NEW) - Moved here for co-location
├── message.go             (MODIFIED) - Existing Go types and methods
└── message_test.go        (MODIFIED) - Tests updated for protobuf
```

## 6. Code Generation Design

### 6.1 Generation Command

```bash
protoc \
  --go_out=. \
  --go_opt=paths=source_relative \
  --proto_path=pkg/protocol/pb \
  pkg/protocol/pb/message.proto
```

**Options explained:**
- `--go_out=.` - Output to current directory
- `--go_opt=paths=source_relative` - Use source-relative paths
- `--proto_path=pkg/protocol/pb` - Where to find .proto files
- Output will be: `pkg/protocol/pb/message.pb.go`

### 6.2 Automation Strategy

#### go:generate Directive

Add to `pkg/protocol/message.go`:

```go
//go:generate protoc --go_out=. --go_opt=paths=source_relative --proto_path=pb pb/message.proto
```

**Rationale:**
- Standard Go tooling
- Self-documenting (command in source file)
- Developers run `go generate ./...` to regenerate

#### devbox Integration

Add to `devbox.json`:

```json
{
  "shell": {
    "scripts": {
      "generate": "go generate ./...",
      "build": "devbox run generate && go build ./..."
    }
  }
}
```

**Rationale:**
- `devbox run generate` calls `go generate`, which triggers the go:generate directive
- Integrates with existing devbox setup
- Consistent with project's development workflow
- Ensures protoc is available via devbox

### 6.3 Chosen Approach: Two-layered

**Decision:** Use go:generate + devbox wrapper

1. **go:generate** - Core code generation mechanism
2. **devbox script** - Wrapper that calls `go generate`

**Rationale:**
- go:generate is the standard Go approach
- devbox provides environment consistency
- No additional build tools (Make) required
- Simple and maintainable

### 6.4 Documentation

Add documentation to:
1. `README.md` - How to regenerate protobuf code
2. `CONTRIBUTING.md` - When to regenerate (after modifying .proto)
3. Code comments - Link to proto file from message.go

## 7. Test Strategy Design

### 7.1 TDD Cycle for Migration

The migration will follow strict TDD with the following cycles:

#### Cycle 1: Protobuf Schema Creation
- **Red:** N/A (no tests yet)
- **Green:** Create .proto file and generate code
- **Refactor:** N/A

**Commit:** `build: add protocol buffer schema for Message`

#### Cycle 2: Protobuf Code Generation
- **Red:** N/A (build/generation step)
- **Green:** Generate .pb.go file
- **Refactor:** N/A

**Commit:** `build: generate Go code from protobuf schema`

#### Cycle 3: Conversion Functions
- **Red:** Write tests for `toProto()` and `fromProto()`
- **Green:** Implement conversion functions
- **Refactor:** Simplify if needed

**Commit:** `test: add tests for protobuf conversion functions` → `refactor: add protobuf conversion functions`

#### Cycle 4: Encode Method
- **Red:** Modify `TestMessage_Encode` to verify protobuf encoding
- **Green:** Implement protobuf-based `Encode()`
- **Refactor:** Clean up unused gob imports

**Commit:** `test: update Encode tests for protobuf` → `refactor: implement protobuf encoding`

#### Cycle 5: Decode Method
- **Red:** Modify `TestMessage_Decode` to verify protobuf decoding
- **Green:** Implement protobuf-based `Decode()`
- **Refactor:** N/A

**Commit:** `test: update Decode tests for protobuf` → `refactor: implement protobuf decoding`

#### Cycle 6: Round-trip Test
- **Red:** `TestMessage_EncodeDecodeRoundTrip` should already pass
- **Green:** Verify it passes
- **Refactor:** N/A

**Commit:** (No commit needed if test already passes)

#### Cycle 7: Cleanup
- **Red:** N/A
- **Green:** Remove gob imports and unused code
- **Refactor:** N/A

**Commit:** `refactor: remove gob dependencies from message.go`

### 7.2 Test Modifications

#### 7.2.1 Unit Tests (pkg/protocol/message_test.go)

**No test case changes required.** All existing test cases remain valid:
- `TestMessage_Encode` - Tests that encoding produces bytes
- `TestMessage_Decode` - Tests that decoding works
- `TestMessage_EncodeDecodeRoundTrip` - Tests round-trip correctness
- `TestMessageType_String` - Tests string representation (unchanged)

**Implementation changes only:**
- Tests verify behavior, not implementation details
- Protobuf-encoded bytes will differ from gob-encoded bytes, but tests don't check byte content
- All existing assertions remain valid

#### 7.2.2 Integration Tests

**No changes required** to:
- `internal/server/server_test.go`
- `internal/client/client_test.go`
- `test/integration_test.go`

**Rationale:**
- These tests use the public API (`Encode()`/`Decode()`)
- Public API signatures unchanged
- Tests verify behavior, not encoding format

### 7.3 Test Execution Strategy

**Order of test execution during implementation:**

1. **Unit tests first:** `go test ./pkg/protocol/...`
2. **Integration tests second:** `go test ./internal/...`
3. **E2E tests last:** `go test ./test/...`

**Expected behavior:**
- After implementing Encode(): Unit tests pass, integration tests may fail
- After implementing Decode(): All tests should pass
- If integration tests fail after both are implemented, there's a bug

### 7.4 Additional Tests

**New tests to add:**

1. **Conversion function tests:**
```go
func TestMessage_toProto(t *testing.T)
func TestMessage_fromProto(t *testing.T)
func TestMessageTypeToProto(t *testing.T)
func TestMessageTypeFromProto(t *testing.T)
```

2. **Unknown enum handling test:**
```go
func TestMessageTypeFromProto_Unknown(t *testing.T) {
    // Test that unknown protobuf enum value defaults to TEXT
}
```

## 8. Migration Steps Summary

### 8.1 Step-by-Step Implementation Plan

| Step | Description | Type | TDD Phase | Commit Message |
|------|-------------|------|-----------|----------------|
| 1 | Create `pkg/protocol/pb/message.proto` | Build | N/A | `build: add protocol buffer schema for Message` |
| 2 | Generate `pkg/protocol/pb/message.pb.go` | Build | N/A | `build: generate Go code from protobuf schema` |
| 3 | Add go:generate directive to `message.go` | Build | N/A | `build: add go:generate directive for protobuf` |
| 4 | Update devbox.json with generate script | Build | N/A | `build: add devbox script for code generation` |
| 5 | Write tests for conversion functions | Test | Red | `test: add tests for protobuf conversion functions` |
| 6 | Implement conversion functions | Refactor | Green | `refactor: add protobuf conversion functions` |
| 7 | Update `Encode()` tests if needed | Test | Red | `test: update Encode tests for protobuf` |
| 8 | Implement protobuf-based `Encode()` | Refactor | Green | `refactor: implement protobuf encoding in Message.Encode()` |
| 9 | Update `Decode()` tests if needed | Test | Red | `test: update Decode tests for protobuf` |
| 10 | Implement protobuf-based `Decode()` | Refactor | Green | `refactor: implement protobuf decoding in Message.Decode()` |
| 11 | Run all tests to verify | Test | Verify | (No commit, verification only) |
| 12 | Remove gob imports | Refactor | Refactor | `refactor: remove gob dependencies from message.go` |
| 13 | Run golangci-lint | Test | Verify | (No commit if passes, fix if needed) |
| 14 | Update architecture.md | Docs | N/A | `docs: update architecture.md for protobuf usage` |

### 8.2 Rollback Strategy

Each step is designed to be independently committable and revertable:

- Steps 1-4: Can be removed without affecting existing functionality
- Steps 5-6: Only add internal functions, no breaking changes
- Steps 7-8: First breaking change (Encode implementation)
  - If issues occur: `git revert` step 8, keep step 7 as "known failing test"
- Steps 9-10: Second breaking change (Decode implementation)
  - If issues occur: `git revert` step 10, keep step 9 as "known failing test"

### 8.3 Validation Checklist

After completing all steps, verify:

- [ ] All unit tests pass: `go test ./pkg/protocol/...`
- [ ] All integration tests pass: `go test ./internal/...`
- [ ] All E2E tests pass: `go test ./test/...`
- [ ] golangci-lint passes: `golangci-lint run`
- [ ] Build succeeds: `go build ./...`
- [ ] No gob imports remain: `grep -r "encoding/gob" pkg/protocol/`
- [ ] Generated code is committed
- [ ] Documentation is updated
- [ ] All commits follow conventional commit format
- [ ] All commit messages explain WHY in the body

## 9. Risk Mitigation

### 9.1 Risk: Naming Conflicts

**Risk:** Generated protobuf code creates types with same names as existing types

**Mitigation:** Generate to `pkg/protocol/pb/` subdirectory

**Verification:** Build succeeds without naming conflicts

### 9.2 Risk: Test Failures During Migration

**Risk:** Tests fail during intermediate steps

**Mitigation:** Follow TDD strictly, commit frequently, each step is revertable

**Verification:** Tests pass at each Green phase

### 9.3 Risk: Integration Issues

**Risk:** Server/client can't communicate after migration

**Mitigation:** Run integration tests after each change, verify end-to-end

**Verification:** `test/integration_test.go` passes

### 9.4 Risk: Performance Regression

**Risk:** Protobuf encoding is slower than gob

**Mitigation:** Not a primary concern (per requirements), but can be measured

**Verification:** (Optional) Benchmark tests if performance becomes a concern

### 9.5 Risk: Generated Code Conflicts

**Risk:** Generated .pb.go conflicts with manual changes

**Mitigation:**
- Never manually edit .pb.go
- Clear documentation on regeneration
- Use pb/ subdirectory to separate concerns

**Verification:** Check .pb.go has "DO NOT EDIT" warning

## 10. Open Questions

### 10.1 Should generated code be committed?

**Answer:** YES (per requirement FR2.2)

**Rationale:**
- Ensures all contributors have identical generated code
- Reduces risk of version mismatches
- Makes builds reproducible without requiring protoc

### 10.2 Should we version the .proto file?

**Answer:** NO (out of scope for this migration)

**Rationale:**
- Clean migration, no versioning needed
- All components updated simultaneously
- Can be added later if needed

### 10.3 Should we add protobuf validation?

**Answer:** NO (out of scope for this migration)

**Rationale:**
- Current implementation has no validation
- Adding validation would be a feature change
- Can be added in a future commit

## 11. Success Criteria

This design successfully addresses the requirements when:

1. ✅ Protocol Buffer schema is defined in `pkg/protocol/pb/message.proto`
2. ✅ Generated code is in `pkg/protocol/pb/message.pb.go`
3. ✅ Existing API surface is maintained (no breaking changes)
4. ✅ `Encode()` and `Decode()` use protobuf
5. ✅ All existing tests pass without modification to test logic
6. ✅ Code generation is automated (go:generate, Make, devbox)
7. ✅ TDD approach is followed for all changes
8. ✅ All commits are atomic and follow conventional commit format
9. ✅ Documentation is updated
10. ✅ No gob imports remain in production code

## 12. Appendix: Alternative Designs Considered

### A. Direct Replacement (Rejected)

Replace existing types entirely with protobuf-generated types.

**Rejected because:**
- Violates requirement FR3.3 (maintain method signatures)
- Would require changes throughout codebase
- Higher risk of breaking changes

### B. Wrapper Types (Rejected)

Create wrapper structs that embed protobuf types.

**Rejected because:**
- Adds unnecessary complexity
- Leaks protobuf implementation details
- Makes testing more complex

### C. Interface-Based Abstraction (Rejected)

Create an interface for encoding/decoding, with gob and protobuf implementations.

**Rejected because:**
- Over-engineered for this use case
- No requirement for multiple encoding formats
- Adds complexity without benefit

### D. Chosen: Conversion Layer (Accepted)

Maintain existing types, convert to/from protobuf for serialization only.

**Accepted because:**
- ✅ Maintains existing API
- ✅ Isolates protobuf details
- ✅ Minimal changes to existing code
- ✅ Clear separation of concerns
- ✅ Easy to test and maintain

## 13. Next Steps

After this design document is approved:

1. Proceed to implementation planning phase
2. Create detailed implementation plan with exact code changes
3. Begin implementation following TDD
